
라즈베리 파이에 외장 하드나 USB 메모리를 연결하면, 대부분의 경우 **자동 인식**은 되지만, **자동 마운트(auto-mount)** 까지 되는지는 몇 가지 조건에 따라 다릅니다.

---

## ✅ 기본 동작 요약

| 조건 | 자동 인식 | 자동 마운트 |
|------|------------|--------------|
| GUI 버전 (Desktop) | O | O (`/media/pi/...`) |
| Lite 버전 (CLI만 있는 버전) | O | ❌ (수동 마운트 필요) |

라즈베리 파이 OS Lite에서는 **디바이스는 인식하지만 자동으로 마운트되지 않으므로 수동 마운트** 해줘야 합니다.

---

## ✅ 1. 디바이스 인식 확인

```bash
lsblk
```

또는

```bash
sudo fdisk -l
```

예시:
```
sda      8:0    0  14.9G  0 disk
└─sda1   8:1    0  14.9G  0 part
```

> `sda1` 같은 이름이 보이면 외장 디스크가 인식된 것입니다.

---

## ✅ 2. 수동 마운트 예시

```bash
sudo mkdir /mnt/usb
sudo mount /dev/sda1 /mnt/usb
```

> 대부분 FAT32/NTFS/exFAT로 되어 있기 때문에 바로 마운트됩니다.

### 포맷별 마운트 관련 패키지 (필요 시)

```bash
sudo apt install exfat-fuse ntfs-3g
```

---

## ✅ 3. 자동 마운트 원할 경우 (`/etc/fstab`)

```bash
sudo blkid
```

예시 출력:
```
/dev/sda1: UUID="A1B2-C3D4" TYPE="vfat"
```

`/etc/fstab`에 추가:

```ini
UUID=A1B2-C3D4  /mnt/usb  vfat  defaults,noatime  0  0
```

→ 부팅 시 자동 마운트됩니다.

---

## ✅ 마운트 해제 (언마운트)

```bash
sudo umount /mnt/usb
```

---

## ✅ 권한 문제

마운트 후 파일/폴더 접근이 안 될 경우:

```bash
sudo chown -R pi:pi /mnt/usb

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



좋습니다! `CommandUtil`을 사용하여 각 프로그램이 설치돼 있는지 확인하고, **설치되지 않은 경우 자동으로 설치**까지 진행하는 로직을 Java로 구현할 수 있습니다.

라즈베리파이(데비안 계열) 기준으로 `apt install`을 이용한 자동 설치를 예시로 드리겠습니다.

---

## ✅ 설치 확인 및 자동 설치 유틸 (`checkAndInstallTools` 메서드)

```java
@Slf4j
public class SetupUtil {

    public static void checkAndInstallTools() {
        checkAndInstall("python3", "python3", "--version", "sudo", "apt", "install", "-y", "python3");
        checkAndInstall("pip3", "pip3", "--version", "sudo", "apt", "install", "-y", "python3-pip");
        checkAndInstall("ffmpeg", "ffmpeg", "-version", "sudo", "apt", "install", "-y", "ffmpeg");
        checkAndInstall("exiftool", "exiftool", "-ver", "sudo", "apt", "install", "-y", "libimage-exiftool-perl");
    }

    private static void checkAndInstall(String name, String checkCommand, String checkArg, String... installCommand) {
        List<String> result = CommandUtil.workExe(checkCommand, checkArg);

        boolean installed = result.stream()
                .anyMatch(line -> !line.toLowerCase().contains("not found") && !line.toLowerCase().contains("command not found"));

        if (installed) {
            log.info("[{}] is already installed.", name);
        } else {
            log.warn("[{}] not installed. Installing...", name);
            List<String> installResult = CommandUtil.workExe(installCommand);
            installResult.forEach(line -> log.info("[{} 설치결과] {}", name, line));
        }
    }
}
```

---

## ✅ 사용 예시

```java
public class IntroService {

    public void onStartup() {
        log.info("필수 도구 설치 확인 중...");
        SetupUtil.checkAndInstallTools();
        // 이후 파이썬 스크립트 복사, 라이브러리 설치 등 진행
    }
}
```

---

## 🧠 보완 팁

- **에러 처리 강화**: `CommandUtil.workExe()` 결과가 `"Unable to locate package"` 등 포함 시 예외 처리 가능
- **환경에 따라 `sudo` 생략** 가능 (root 권한으로 실행되는 경우)
- **인터넷 연결 확인**도 필요할 수 있음

---




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 










맞습니다. 그 판단은 매우 전략적이고 구조적입니다 👏  
파일 확장자별로 **공통 처리와 분기 처리**를 명확히 하면 코드 유지보수성과 성능이 훨씬 좋아집니다. 특히:

- `.jpg`, `.jpeg`: EXIF 썸네일 존재 시 빠르게 추출 가능 (속도 우위)
- `.png`, `.bmp`, `.gif`, `.webp`: EXIF 없음 → PIL로 직접 썸네일 생성
- `.mp4`, `.mov`, `.mkv`: ffmpeg로 특정 프레임 캡처
- `.cr2`: exiftool 또는 rawpy로 처리

---

## ✅ 추천 구조 설계 (파이썬 파일 구성 기준)

### 📁 `media_processor/`
```
__init__.py
common.py              ← 공통 유틸 (썸네일 Base64, 파일 저장, JSON 출력 등)
image_base.py          ← 기본 이미지 처리 (png, bmp, gif, webp)
image_exif.py          ← exif 포함 이미지 처리 (jpg, jpeg)
video_ffmpeg.py        ← mp4, mov, mkv 등 동영상 처리
raw_cr2.py             ← cr2 전용 RAW 처리
main.py                ← 확장자에 따라 분기 호출 (CommandUtil에서 이 파일만 호출)
```

---

## ✅ 예시 흐름: `main.py`

```python
import sys
from pathlib import Path
from media_processor.image_base import process_image_base
from media_processor.image_exif import process_image_exif
from media_processor.video_ffmpeg import process_video
from media_processor.raw_cr2 import process_cr2

def main(file_no, file_path):
    path = Path(file_path)
    ext = path.suffix.lower()

    if ext in {".png", ".bmp", ".gif", ".webp"}:
        result = process_image_base(file_no, path)
    elif ext in {".jpg", ".jpeg"}:
        result = process_image_exif(file_no, path)
    elif ext in {".mp4", ".mov", ".mkv"}:
        result = process_video(file_no, path)
    elif ext in {".cr2"}:
        result = process_cr2(file_no, path)
    else:
        result = {"error": f"Unsupported file extension: {ext}"}

    print(result)  # stdout → Java가 CommandUtil 통해 받음

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print({"error": "Usage: main.py <fileNo> <filePath>"})
    else:
        main(int(sys.argv[1]), sys.argv[2])
```

---

## ✅ 장점 요약

| 항목 | 장점 |
|------|------|
| 분리된 구조 | 유지보수 및 기능 확장 용이 |
| 공통 유틸 (`common.py`) | Base64 인코딩, 썸네일 저장 등 중복 제거 |
| 확장자 기반 처리 | 더 빠르고 안정적인 실행 가능 |
| CommandUtil 출력 기반 stdout | HTTP 미사용으로 통신 실패 없음 |

---

## 🧩 다음 단계 제안

원하신다면 각 모듈 예시(`image_exif.py`, `video_ffmpeg.py` 등)를 **실제 구현 형태로 제공**드릴 수 있습니다.  
한 번에 전체 생성도 가능하고, 단계별로 순차 진행도 가능합니다.

어떤 방식으로 이어서 도와드릴까요?  
(예: `image_exif.py`부터 작성, 전체 기본 틀 scaffold 제공 등)






좋습니다! 그럼 **확장자별 분리 구조를 기반으로 실제 파이썬 코드 구성**을 바로 진행하겠습니다.

---

## ✅ 1. 디렉토리 구조

```bash
BurrowNest/
└── python-utils/
    ├── main.py                 # 🎯 확장자에 따라 분기
    ├── common.py               # 🔧 공통 유틸: 썸네일, base64, 시간, JSON 출력 등
    ├── image_base.py           # 🖼 PNG, BMP, WEBP, GIF
    ├── image_exif.py           # 📸 JPG, JPEG (EXIF 포함)
    ├── video_ffmpeg.py         # 🎞 MP4, MOV, MKV
    ├── raw_cr2.py              # 📷 CR2 전용 처리
```

---

## ✅ 2. `main.py` – 확장자 분기

```python
import sys
from pathlib import Path
from common import print_json
from image_base import process_image_base
from image_exif import process_image_exif
from video_ffmpeg import process_video
from raw_cr2 import process_cr2

def main(file_no, file_path):
    path = Path(file_path)
    ext = path.suffix.lower()

    if ext in {".png", ".bmp", ".gif", ".webp"}:
        result = process_image_base(file_no, path)
    elif ext in {".jpg", ".jpeg"}:
        result = process_image_exif(file_no, path)
    elif ext in {".mp4", ".mov", ".mkv"}:
        result = process_video(file_no, path)
    elif ext == ".cr2":
        result = process_cr2(file_no, path)
    else:
        result = {"fileNo": file_no, "error": f"Unsupported extension: {ext}"}

    print_json(result)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print_json({"error": "Usage: main.py <fileNo> <filePath>"})
    else:
        main(int(sys.argv[1]), sys.argv[2])
```

---

## ✅ 3. `common.py` – 유틸 모음

```python
import base64
from io import BytesIO
import json
from PIL import Image
from datetime import datetime

def now_millis():
    return int(datetime.now().timestamp() * 1000)

def now_time():
    return datetime.now().strftime("%H:%M:%S")

def image_to_base64(image):
    buffer = BytesIO()
    image.save(buffer, format="JPEG")
    return f"data:image/jpeg;base64,{base64.b64encode(buffer.getvalue()).decode()}"

def file_to_base64(path):
    with open(path, "rb") as f:
        return f"data:image/jpeg;base64,{base64.b64encode(f.read()).decode()}"

def print_json(obj):
    print(json.dumps(obj))
```

---

## ✅ 4. `image_base.py` – PNG, BMP 등

```python
from PIL import Image
from common import image_to_base64, now_millis, now_time

def process_image_base(file_no, path):
    try:
        with Image.open(path) as img:
            img.thumbnail((200, 200))
            thumb = image_to_base64(img)
            return {
                "fileNo": file_no,
                "cameraModel": "",
                "cameraManufacturer": "",
                "apertureValue": 0.0,
                "shutterSpeed": 0.0,
                "isoValue": 0,
                "focalLength": 0.0,
                "captureDate": now_millis(),
                "captureTime": now_time(),
                "imageWidth": img.width,
                "imageHeight": img.height,
                "gpsLatitude": 0.0,
                "gpsLongitude": 0.0,
                "flashUsed": False,
                "whiteBalance": "AUTO",
                "sceneMode": "Auto",
                "softwareVersion": "V.0.1.1",
                "thumbnail": thumb
            }
    except Exception as e:
        return {"fileNo": file_no, "error": str(e)}
```

---

## 🔜 다음 제공 예정

- `image_exif.py` – EXIF 기반 JPG 처리
- `video_ffmpeg.py` – ffmpeg 영상 썸네일/메타데이터 추출
- `raw_cr2.py` – exiftool 또는 rawpy 기반 cr2 처리

---

이 구조로 쭉 확장해나가면, BurrowNest에서 관리하기에 깔끔하고 안정적인 구성입니다.  
다음은 `image_exif.py`부터 이어서 제공드릴까요?












좋습니다! 이어서 `.jpg`, `.jpeg` 파일 처리를 위한 `image_exif.py` 코드를 드리겠습니다.  
이 모듈은 **EXIF 정보가 있으면 추출하고**, 없으면 일반 이미지로 처리합니다.  
추출 가능한 정보: 카메라 모델, 제조사, FNumber(조리개), ISO, 초점 거리, 셔터속도, GPS 등

---

## ✅ `image_exif.py` – JPG/JPEG 처리

```python
from PIL import Image, ExifTags
from common import image_to_base64, now_millis, now_time

def get_exif(img):
    try:
        exif_data = img._getexif() or {}
        return {
            ExifTags.TAGS.get(k, k): v
            for k, v in exif_data.items()
            if k in ExifTags.TAGS
        }
    except Exception:
        return {}

def convert_gps(coord):
    try:
        d, m, s = coord
        return d[0]/d[1] + m[0]/m[1]/60 + s[0]/s[1]/3600
    except Exception:
        return 0.0

def process_image_exif(file_no, path):
    try:
        with Image.open(path) as img:
            exif = get_exif(img)
            img.thumbnail((200, 200))
            thumb = image_to_base64(img)

            result = {
                "fileNo": file_no,
                "cameraModel": exif.get("Model", ""),
                "cameraManufacturer": exif.get("Make", ""),
                "apertureValue": float(exif.get("FNumber", [0, 1])[0]) / (exif.get("FNumber", [1, 1])[1] or 1),
                "shutterSpeed": float(exif.get("ExposureTime", [0, 1])[0]) / (exif.get("ExposureTime", [1, 1])[1] or 1),
                "isoValue": int(exif.get("ISOSpeedRatings", 0)),
                "focalLength": float(exif.get("FocalLength", [0, 1])[0]) / (exif.get("FocalLength", [1, 1])[1] or 1),
                "captureDate": now_millis(),
                "captureTime": now_time(),
                "imageWidth": img.width,
                "imageHeight": img.height,
                "gpsLatitude": convert_gps(exif.get("GPSInfo", {}).get(2, [(0, 1), (0, 1), (0, 1)])),
                "gpsLongitude": convert_gps(exif.get("GPSInfo", {}).get(4, [(0, 1), (0, 1), (0, 1)])),
                "flashUsed": exif.get("Flash", 0) != 0,
                "whiteBalance": exif.get("WhiteBalance", "AUTO"),
                "sceneMode": exif.get("SceneCaptureType", "Auto"),
                "softwareVersion": "V.0.1.1",
                "thumbnail": thumb
            }
            return result

    except Exception as e:
        return {"fileNo": file_no, "error": str(e)}
```

---

## ✅ 요약

| 항목 | 설명 |
|------|------|
| 썸네일 | `img.thumbnail()` → base64 인코딩 |
| EXIF | 조리개(FNumber), ISO, 셔터속도, 초점거리, GPS 등 |
| fallback | EXIF 없음 시에도 기본 처리 가능 |
| 포맷 | Java와 연동 가능한 JSON 구조로 stdout 출력 (`main.py`에서)

---

다음은 `video_ffmpeg.py` → `.mp4`, `.mov`, `.mkv` 영상 처리 모듈 이어서 제공드리겠습니다.  
계속 진행할까요?
















좋습니다! 이어서 `.mp4`, `.mov`, `.mkv` 등의 **영상 파일을 처리하는 `video_ffmpeg.py`** 모듈을 작성해드리겠습니다.

이 모듈은:

1. `ffprobe`로 메타데이터(해상도, duration, 장비 정보 등) 추출  
2. `ffmpeg`로 썸네일 프레임 생성  
3. 공통 포맷(JSON)으로 리턴 → stdout은 `main.py`에서 출력

---

## ✅ `video_ffmpeg.py`

```python
import subprocess
import json
from pathlib import Path
from common import file_to_base64, now_millis, now_time
import uuid

def extract_metadata(path: Path):
    try:
        cmd = [
            "ffprobe",
            "-v", "error",
            "-select_streams", "v:0",
            "-show_entries", "stream=width,height,duration",
            "-show_format",
            "-of", "json",
            str(path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        data = json.loads(result.stdout)

        stream = data.get("streams", [{}])[0]
        fmt = data.get("format", {})
        tags = fmt.get("tags", {})

        creation_time = tags.get("creation_time", "")
        width = int(stream.get("width", 0))
        height = int(stream.get("height", 0))
        duration = float(fmt.get("duration", 0.0))

        return {
            "imageWidth": width,
            "imageHeight": height,
            "duration": duration,
            "cameraModel": tags.get("com.apple.quicktime.model", ""),
            "cameraManufacturer": tags.get("com.apple.quicktime.make", ""),
            "captureDate": now_millis(),
            "captureTime": now_time()
        }

    except Exception as e:
        return {"error": f"[ffprobe] {str(e)}"}



def generate_thumbnail(path: Path) -> str:
    # UUID 기반 임시 썸네일 파일 생성
    thumb_path = Path(f"/tmp/{uuid.uuid4().hex}.jpg")

    try:
        cmd = [
            "ffmpeg",
            "-y",
            "-i", str(path),
            "-ss", "00:00:01",
            "-vframes", "1",
            "-vf", "scale=200:-1",
            str(thumb_path)
        ]
        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)

        result = file_to_base64(thumb_path)

    except Exception as e:
        print(f"[썸네일 생성 오류] {e}")
        result = ""
    finally:
        try:
            if thumb_path.exists():
                thumb_path.unlink()
        except Exception as e:
            print(f"[임시 파일 삭제 오류] {e}")

    return result


def process_video(file_no, path: Path):
    meta = extract_metadata(path)
    if "error" in meta:
        return {"fileNo": file_no, "error": meta["error"]}

    return {
        "fileNo": file_no,
        "cameraModel": meta.get("cameraModel", ""),
        "cameraManufacturer": meta.get("cameraManufacturer", ""),
        "apertureValue": 0.0,
        "shutterSpeed": 0.0,
        "isoValue": 0,
        "focalLength": 0.0,
        "captureDate": meta["captureDate"],
        "captureTime": meta["captureTime"],
        "imageWidth": meta["imageWidth"],
        "imageHeight": meta["imageHeight"],
        "gpsLatitude": 0.0,
        "gpsLongitude": 0.0,
        "flashUsed": False,
        "whiteBalance": "AUTO",
        "sceneMode": "Auto",
        "softwareVersion": "V.0.1.1",
        "thumbnail": generate_thumbnail(path)
    }
```

---

## ✅ 특징 요약

| 항목 | 설명 |
|------|------|
| 썸네일 | `ffmpeg -ss 1초` 캡처 + scale 200px |
| 메타데이터 | `ffprobe`로 해상도, 장비 정보 추출 |
| 안전성 | 실패 시 `"error"` 필드로 처리 |
| base64 | 썸네일 결과는 Java에서 즉시 사용 가능

---

다음은 `.cr2` 전용 모듈 `raw_cr2.py` 준비해드릴게요.  
계속 이어갈까요?









좋습니다! 마지막으로 **RAW 이미지 포맷인 `.cr2` 파일 전용 처리 모듈 `raw_cr2.py`** 를 작성해드리겠습니다.  
이 모듈은 `exiftool`을 이용해서 썸네일과 메타데이터를 추출합니다.

---

## ✅ `raw_cr2.py`

```python
import json
from common import file_to_base64, now_millis, now_time
import uuid
import os
from pathlib import Path
import subprocess
from common import file_to_base64

def extract_exiftool_json(path: Path):
    try:
        result = subprocess.run(
            ["exiftool", "-j", "-n", str(path)],
            capture_output=True,
            text=True,
            check=True
        )
        json_data = json.loads(result.stdout)[0]
        return json_data
    except Exception as e:
        return {"error": f"[exiftool json] {str(e)}"}



def extract_thumbnail(path: Path) -> str:
    # 고유한 임시 파일 이름 생성
    temp_name = f"/tmp/{uuid.uuid4().hex}.jpg"
    temp_path = Path(temp_name)

    try:
        with open(temp_path, "wb") as out:
            subprocess.run(
                ["exiftool", "-b", "-ThumbnailImage", str(path)],
                stdout=out,
                stderr=subprocess.DEVNULL,
                check=True
            )

        # Base64 변환
        result = file_to_base64(temp_path)

    except Exception as e:
        print(f"[썸네일 추출 오류] {e}")
        result = ""
    finally:
        # 파일 삭제
        try:
            if temp_path.exists():
                temp_path.unlink()
        except Exception as e:
            print(f"[임시 파일 삭제 실패] {e}")

    return result


def process_cr2(file_no, path: Path):
    exif = extract_exiftool_json(path)
    if "error" in exif:
        return {"fileNo": file_no, "error": exif["error"]}

    return {
        "fileNo": file_no,
        "cameraModel": exif.get("Model", ""),
        "cameraManufacturer": exif.get("Make", ""),
        "apertureValue": float(exif.get("ApertureValue", 0.0)),
        "shutterSpeed": float(exif.get("ShutterSpeedValue", 0.0)),
        "isoValue": int(exif.get("ISO", 0)),
        "focalLength": float(exif.get("FocalLength", 0.0)),
        "captureDate": now_millis(),
        "captureTime": now_time(),
        "imageWidth": int(exif.get("ImageWidth", 0)),
        "imageHeight": int(exif.get("ImageHeight", 0)),
        "gpsLatitude": float(exif.get("GPSLatitude", 0.0)),
        "gpsLongitude": float(exif.get("GPSLongitude", 0.0)),
        "flashUsed": exif.get("Flash", "") != "No Flash",
        "whiteBalance": exif.get("WhiteBalance", "AUTO"),
        "sceneMode": exif.get("SceneCaptureType", "Auto"),
        "softwareVersion": "V.0.1.1",
        "thumbnail": extract_thumbnail(path)
    }
```

---

## ✅ 핵심 요약

| 항목 | 설명 |
|------|------|
| 썸네일 추출 | `exiftool -b -ThumbnailImage`로 JPEG 추출 |
| 메타데이터 | `exiftool -j -n`으로 JSON 파싱 |
| 호환성 | CR2 전용. 타 포맷은 `exiftool` 작동 방식 다름 |
| 속도 | 매우 빠름 (썸네일 내장 JPEG 사용) |

---

## ✅ 전체 구조 완성

✅ 이로써 확장자 기반 전체 파이썬 구조는 다음처럼 완성되었습니다:

- `main.py`: 분기 처리
- `common.py`: 유틸
- `image_base.py`: `.png`, `.bmp`, `.gif`, `.webp`
- `image_exif.py`: `.jpg`, `.jpeg`
- `video_ffmpeg.py`: `.mp4`, `.mov`, `.mkv`
- `raw_cr2.py`: `.cr2`

---

다음으로 원하시면:

- `requirements.txt` 생성
- 설치 자동화 (`CommandUtil` + `Intro 페이지`)
- Java 연동 및 테스트 코드

같이 정리해드릴 수 있어요. 어떤 걸 다음으로 도와드릴까요?







두 코드 모두 **브라우저 주소창(URL)을 변경하지만 페이지를 새로고침하지 않는 점은 동일**합니다.
하지만 **기록(history)에 저장되는 방식**이 다릅니다:

---

### ✅ `window.history.pushState({}, '', '/new-url')`

* **브라우저 히스토리에 새 항목을 추가**합니다.
* 즉, 사용자가 뒤로 가기(← Back)를 누르면 **이전 URL로 돌아갈 수 있습니다**.
* 사용 예:

  * 사용자가 어떤 상태에서 필터/검색 등을 하고 URL을 반영할 때

```js
history.pushState({}, '', '/search?keyword=apple');
// 사용자가 이전 페이지로 Back 가능
```

---

### ✅ `window.history.replaceState({}, '', '/new-url')`

* **히스토리 항목을 덮어씌웁니다.**
* 즉, **현재 페이지의 URL을 바꾸되, 이전 URL로 돌아갈 수 없습니다.**
* 사용 예:

  * 초기 상태를 덮어씌우거나, 잘못된 쿼리스트링을 제거하거나, 새로고침시 동일 URL 유지하고 싶을 때

```js
history.replaceState({}, '', '/clean-url');
// Back 눌러도 이전 URL로 못 돌아감
```

---

### 📌 차이 요약

| 항목                | `pushState()` | `replaceState()`  |
| ----------------- | ------------- | ----------------- |
| 히스토리 추가 여부        | ✅ 새 항목 추가     | ❌ 기존 항목 덮어쓰기      |
| 뒤로 가기(Back) 가능 여부 | ✅ 가능          | ❌ 불가능             |
| 사용 목적 예시          | 사용자 동작 기록 유지  | 초기 상태 수정, 쿼리 제거 등 |

---

### ✨ 실전 팁

```js
// 검색창 입력 시마다 주소를 갱신하지만 기록은 남기지 않게 하려면:
history.replaceState({}, '', '/search?term=apple');

// 페이지 이동 시에는 기록을 남겨야 하므로:
history.pushState({}, '', '/page2');
```

더 필요한 시나리오가 있으면 알려주세요.









맞습니다. 사용자마다 여러 개의 최상위 디렉토리를 가질 수 있고, 그것들은 반드시 `BN_DIRECTORY.NO = 1`일 필요는 없습니다.

---

### ✅ 사용자 중심의 "최상위 디렉토리" 조회 정의

**최상위 디렉토리** =

* `PARENT_NO`는 존재하지만,
* 그 `PARENT_NO`가 사용자가 접근 가능한 디렉토리 중 **상위에 없음**
  또는
* `PARENT_NO = 0` 혹은 가상의 루트(미정의 루트)

**하지만 실용적으로는 다음 조건을 만족하면 "사용자 기준의 최상위 디렉토리"로 간주할 수 있습니다:**

---

### ✅ 사용자 접근 가능한 디렉토리 중 `PARENT_NO`가 없는(루트) 디렉토리

```sql
SELECT d.*
FROM BN_DIRECTORY d
LEFT JOIN BN_DIRECTORY_ACCESS da 
    ON d.NO = da.DIR_NO AND da.USER_NO = :userNo
WHERE d.PARENT_NO = 0 -- 혹은 NULL, 설계에 따라 조정
  AND (
    d.PUBLIC_ACCESSIBLE = TRUE
    OR d.OWNER_NO = :userNo
    OR BITAND(da.ACCESS_FLAGS, :readBitFlag) != 0
  )
  AND d.ENABLED = TRUE;
```

> `PARENT_NO = 0`이 사용자 정의 루트 디렉토리라고 가정합니다.
> 만약 실제 최상위 디렉토리는 다른 디렉토리에도 부모로 지정되지 않은 디렉토리라면, 하단의 **2차 방식**이 더 적합합니다.

---

### ✅ 대안: "부모가 없는" 사용자 접근 가능 디렉토리 구하기

```sql
SELECT d.*
FROM BN_DIRECTORY d
LEFT JOIN BN_DIRECTORY_ACCESS da 
    ON d.NO = da.DIR_NO AND da.USER_NO = :userNo
LEFT JOIN BN_DIRECTORY parent 
    ON d.PARENT_NO = parent.NO
WHERE (
    d.PUBLIC_ACCESSIBLE = TRUE
    OR d.OWNER_NO = :userNo
    OR BITAND(da.ACCESS_FLAGS, :readBitFlag) != 0
)
AND d.ENABLED = TRUE
AND (
    d.PARENT_NO = 0 OR parent.NO IS NULL -- 상위 디렉토리가 없거나,
    OR NOT EXISTS (
        SELECT 1
        FROM BN_DIRECTORY d2
        WHERE d2.NO = d.PARENT_NO
    )
);
```

---

### 🔍 상황별 고려

| 조건                               | 설명                           |
| -------------------------------- | ---------------------------- |
| `d.PARENT_NO = 0`                | 최상위 디렉토리를 명시적으로 지정했을 경우      |
| `parent.NO IS NULL`              | 상위 디렉토리 자체가 존재하지 않거나 삭제됨     |
| `NOT EXISTS (SELECT 1 FROM ...)` | 상위 디렉토리가 현재 디렉토리 집합에 포함되지 않음 |

---

### 💡 Spring JDBC or JPA 사용 시 주의

* `BITAND()`는 SQL에 직접 넣어야 하며, JPA 함수로는 따로 제공되지 않음.
* `@Query`로 native 쿼리 작성하는 방식 추천

---

혹시 “소유자 기준으로 최상위 디렉토리”만 보고 싶다면 조건 조정 가능합니다. 추가로 하위 디렉토리까지 lazy-load 로 가져오길 원하시나요?



const response = await fetch(accountCancelUrl, {
			     	  method: "POST",
			     	  credentials: "include",
			     	  headers: {
			     		 "Content-Type": "application/x-www-form-urlencoded"
			     	  },
			     	 body: new URLSearchParams(sendValue).toString(),
		     	  });