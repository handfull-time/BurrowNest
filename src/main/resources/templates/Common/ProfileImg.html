<!-- 프로필 이미지 관련 작업 -->

<th:block xmlns:th="http://www.thymeleaf.org" th:fragment="imageEle(userNo, userId)">
<img id="profilePreview" th:src="@{/User/{no}/Profile.img(no=${userNo})}" th:alt="${userId}" class="w-14 h-12 rounded-full border">
<label for="profileImageInput" class="cursor-pointer">
	<span class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-1/2 bg-gray-300 text-white text-[10px] rounded-full w-4 h-4 flex items-center justify-center opacity-50">➕</span>
</label>
<input type="file" id="profileImageInput" class="hidden" accept="image/png, image/jpeg, image/svg+xml">
</th:block>

<th:block xmlns:th="http://www.thymeleaf.org" th:fragment="JoinImageEle">
<img id="profilePreview" th:src="@{/images/profile/DefaultProfile.png}" alt="프로필 이미지" class="w-14 h-12 rounded-full border">
<label for="profileImageInput" class="cursor-pointer">
	<span class="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-1/2 bg-gray-300 text-white text-[10px] rounded-full w-4 h-4 flex items-center justify-center opacity-50">➕</span>
</label>
<input type="file" id="profileImageInput" class="hidden" accept="image/png, image/jpeg, image/svg+xml">
</th:block>

<script xmlns:th="http://www.thymeleaf.org" th:fragment="script">

//프로필 이미지 미리보기 기능
document.getElementById("profileImageInput").addEventListener("change", function(event) {
    const file = event.target.files[0];
    if (! file) {
    	return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
    	const fileType = file.type;
        
        if (fileType === "image/svg+xml") {
            // SVG 처리
            const img = new Image();
            img.onload = function() {
            	document.getElementById("profilePreview").src = convertSVGToPNG(img);
            };
            img.src = e.target.result;
        } else {
            // 일반 이미지 처리 (PNG, JPG)
            const img = new Image();
            img.onload = function() {
            	document.getElementById("profilePreview").src = resizeImage(img);
            };
            img.src = e.target.result;
        }

    };
    reader.readAsDataURL(file);
    
});

function createCanvas(width, height) {
	const canvas = document.createElement("canvas");
	canvas.width = width;
	canvas.height = height;
	return canvas;
}

function convertSVGToPNG(img, maxSize = 100) {
	console.info('convertSVGToPNG', img);
    const canvas = createCanvas(maxSize, maxSize);
    const ctx = canvas.getContext("2d");

    const width = maxSize;
    const height = maxSize;

    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);

    return canvas.toDataURL("image/png");
}

function resizeImage(img, maxSize = 100) {
	console.info('resizeImage', img);
    let width = img.width;
    let height = img.height;

    if (width > maxSize || height > maxSize) {
        if (width > height) {
            height *= maxSize / width;
            width = maxSize;
        } else {
            width *= maxSize / height;
            height = maxSize;
        }
    }

    const canvas = createCanvas(maxSize, maxSize);
    const ctx = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);

    return canvas.toDataURL("image/png");
}

async function getProfileImage() {
	const profileImg = document.getElementById("profilePreview");
	const imageFile = document.getElementById("profileImageInput").files[0];

	if (!imageFile) {
		console.info( '리사이징 안된 원래 이미지 처리');
		const img = new Image();
		img.crossOrigin = "anonymous"; // 크로스오리진 문제 방지
		img.src = profileImg.src;
		
		await new Promise((resolve) => {
			img.onload = function() {
				profileImg.src = convertSVGToPNG(img);
				resolve(); // 이미지 로드가 완료되면 계속 진행
			};
		});
	}

	try {
		const imageUrl = profileImg.src;
		let imageBlob;

		if (imageUrl.startsWith("data:")) {
			// Base64 데이터를 Blob으로 변환
			const byteCharacters = atob(imageUrl.split(",")[1]);
			const byteNumbers = new Array(byteCharacters.length);
			for (let i = 0; i < byteCharacters.length; i++) {
				byteNumbers[i] = byteCharacters.charCodeAt(i);
			}
			const byteArray = new Uint8Array(byteNumbers);
			imageBlob = new Blob([byteArray], { type: "image/png" });
		} else {
			// URL에서 직접 Blob 가져오기
			const response = await fetch(imageUrl);
			imageBlob = await response.blob();
		}

		return new File([imageBlob], "default-profile.png", { type: imageBlob.type });
	} catch (error) {
		console.error("기본 이미지 변환 오류:", error);
		return null;
	}
}
</script>
